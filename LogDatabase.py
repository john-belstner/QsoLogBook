import sqlite3
from Qso import Qso


class LogDatabase:

    columns = ["row_id", "Call", "Name", "Date", "Time", "Band", "Mode", "Report", "PropMode", "Satellite", "Grid", "County", "State", "Country", "CQ", "Freq", "Remarks", "My_Grid"]
    adif_col = ["row_id", "call", "name", "qso_date", "time_on", "band", "mode", "rst_rcvd", "prop_mode", "sat_name", "gridsquare", "county", "state", "country", "cqz", "freq", "remarks", "my_gridsquare"]

    def __init__(self, my_grid="DM43bs"):
        self.db_file = "qso_log.db"
        self.table_name = "logbook"
        self.my_grid = my_grid
        self.conn = sqlite3.connect(self.db_file)
        self.cursor = self.conn.cursor()
        self.create_table()

    def create_table(self):
        create_table_sql = f'''
        CREATE TABLE IF NOT EXISTS {self.table_name} (
            rowid INTEGER PRIMARY KEY AUTOINCREMENT,
            Call TEXT NOT NULL,
            Name TEXT,
            Date TEXT NOT NULL,
            Time TEXT NOT NULL,
            Band TEXT NOT NULL,
            Mode TEXT NOT NULL,
            Report TEXT,
            PropMode TEXT,
            Satellite TEXT,
            Grid TEXT,
            County TEXT,
            State TEXT,
            Country TEXT,
            CQ TEXT,
            Freq TEXT,
            Remarks TEXT,
            My_Grid TEXT NOT NULL
        );
        '''
        self.cursor.execute(create_table_sql)
        self.conn.commit()
    
    def update_my_grid(self, new_grid):
        self.my_grid = new_grid

    def get_current_row_count(self):
        count_sql = f'SELECT COUNT(*) FROM {self.table_name};'
        self.cursor.execute(count_sql)
        count = self.cursor.fetchone()[0]
        if count is None:
            return 0  # Table is empty
        return count

    def get_last_rowid(self):
        last_id_sql = f'SELECT rowid FROM {self.table_name} ORDER BY rowid DESC LIMIT 1;'
        self.cursor.execute(last_id_sql)
        result = self.cursor.fetchone()
        if result is None:
            return 0 # No rows in table 
        return result[0]

    def insert_qso(self, qso: Qso):
        insert_sql = f'''
        INSERT INTO {self.table_name} (Call, Name, Date, Time, Band, Mode, Report, PropMode, Satellite, Grid, County, State, Country, CQ, Freq, Remarks, My_Grid)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
        '''
        self.cursor.execute(insert_sql, (qso.callsign, qso.name, qso.date, qso.time, qso.band, qso.mode, qso.report, qso.prop_mode, qso.satellite, qso.grid, qso.county, qso.state, qso.country, qso.cq, qso.freq, qso.remarks, self.my_grid))
        self.conn.commit()

    def update_qso(self, qso: Qso):
        update_sql = f'''
        UPDATE {self.table_name}
        SET Call = ?, Name = ?, Date = ?, Time = ?, Band = ?, Mode = ?, Report = ?, PropMode = ?, Satellite = ?, Grid = ?, County = ?, State = ?, Country = ?, CQ = ?, Freq = ?, Remarks = ?, My_Grid = ?
        WHERE rowid = ?;
        '''
        self.cursor.execute(update_sql, (qso.callsign, qso.name, qso.date, qso.time, qso.band, qso.mode, qso.report, qso.prop_mode, qso.satellite, qso.grid, qso.county, qso.state, qso.country, qso.cq, qso.freq, qso.remarks, self.my_grid, qso.qso_id))
        self.conn.commit()  

    def fetch_qso_by_id(self, qso_id):
        fetch_sql = f'SELECT * FROM {self.table_name} WHERE rowid = ?;'
        self.cursor.execute(fetch_sql, (qso_id,))
        return self.cursor.fetchone()
    
    def delete_qso(self, qso_id):
        delete_sql = f'DELETE FROM {self.table_name} WHERE rowid = ?;'
        self.cursor.execute(delete_sql, (qso_id,))
        self.conn.commit()

    def fetch_all_qsos(self):
        fetch_sql = f'SELECT * FROM {self.table_name};'
        self.cursor.execute(fetch_sql)
        return self.cursor.fetchall()
    
    def export_to_adif(self, adif_file, appVersion="1.0"):
        try:
            with open(adif_file, 'w') as f:
                # Write ADIF header
                f.write("Generated by QsoLogBook " + "v" + appVersion + "\n")
                f.write("<ADIF_VER:5>3.0.5\n")
                f.write("<PROGRAMID:10>QsoLogBook\n")
                f.write("<EOH>\n")
                
                # Write each QSO
                for row in self.fetch_all_qsos():
                    qso = Qso(
                        qso_id=row[self.adif_col.index("row_id")],
                        callsign=row[self.adif_col.index("call")],
                        name=row[self.adif_col.index("name")],
                        date=row[self.adif_col.index("qso_date")],
                        time=row[self.adif_col.index("time_on")],
                        band=row[self.adif_col.index("band")],
                        mode=row[self.adif_col.index("mode")],
                        report=row[self.adif_col.index("rst_rcvd")],
                        prop_mode=row[self.adif_col.index("prop_mode")],
                        satellite=row[self.adif_col.index("sat_name")],
                        grid=row[self.adif_col.index("gridsquare")],
                        county=row[self.adif_col.index("county")],
                        state=row[self.adif_col.index("state")],
                        country=row[self.adif_col.index("country")],
                        cq=row[self.adif_col.index("cqz")],
                        freq=row[self.adif_col.index("freq")],
                        remarks=row[self.adif_col.index("remarks")],
                        my_grid=row[self.adif_col.index("my_gridsquare")]
                    )
                    f.write(qso.to_adif())
        except Exception as e:
            return False, str(e)
    
        return True, "Export successful"

    def import_from_adif(self, adif_file):
        try:
            with open(adif_file, 'r') as f:
                content = f.read()
            
            records = content.split("<eor>") # Split on <eor> tags
            print(f"Found {len(records)} records in ADIF file.")

            qso_num = self.get_last_rowid()
            for record in records:
                qso_data = {}
                for col in self.adif_col:
                    start_tag = f"<{col}:"
                    if start_tag in record:
                        start_idx = record.index(start_tag) + len(start_tag)
                        end_idx = record.index(">", start_idx)
                        length = int(record[start_idx:end_idx])
                        value_start = end_idx + 1
                        value_end = value_start + length
                        qso_data[col] = record[value_start:value_end].strip()
                    else:
                        qso_data[col] = ""
                
                qso_num += 1
                qso = Qso(
                    qso_id = str(qso_num + 1),
                    callsign=qso_data.get("call", ""),
                    name=qso_data.get("name", ""),
                    date=qso_data.get("qso_date", ""),
                    time=qso_data.get("time_on", ""),
                    band=qso_data.get("band", ""),
                    mode=qso_data.get("mode", ""),
                    report=qso_data.get("rst_rcvd", ""),
                    prop_mode=qso_data.get("prop_mode", ""),
                    satellite=qso_data.get("sat_name", ""),
                    grid=qso_data.get("gridsquare", ""),
                    county=qso_data.get("county", ""),
                    state=qso_data.get("state", ""),
                    country=qso_data.get("country", ""),
                    cq=qso_data.get("cqz", ""),
                    freq=qso_data.get("freq", ""),
                    remarks=qso_data.get("remarks", ""),
                    my_grid=qso_data.get("my_gridsquare", self.my_grid)
                )
                if qso.is_valid():
                    self.insert_qso(qso)
                else:
                    print(f"Skipping invalid QSO: {qso}")

        except Exception as e:
            return False, str(e)

        return True, "Import successful"

    def close(self):
        self.conn.close()